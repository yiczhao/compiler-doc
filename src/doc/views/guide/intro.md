# 简介

> 文档列出了KS前端常用`公共组件`
> 项目中内置的git`子模块`在min目录中，`npm run min`命令导出压缩的组件模块，供后台直出（前端非编译开发）模式使用

-------------
<br>

`为了组件的更新迭代，添加相应版本；具体如下`

### 组件编写注意事项

> **为了完成增量更新，开发时要注意添加VERSION属性**
> 打包后会输出相应版本的文件，如果打包⬇️


```js
export default {
    VERSION:'1.0.0',
    data(){

    }
    [,...]

}
```
<br>

`版本多了产生了如下问题`
> 1 . 打包时导出所有版本（当前解决方式：每次保留老版本，待新版本构建导出后与老版本合为一起提交发布）
> 2 . 多版本文档共存和多版本Demo问题（文档中引入不同版本组件，覆盖声明全局的当前版本组件;原则上可以，但实际造作有些问题）
> 3 . 在大量的业务中使用了老版本组件并出现bug(紧急情况下)，原则上是要更换新版本，由于时间迫切并且更换代价过大，此时可以在老版本中做bugfix；后期找时间更换组件版本

<br>

`怎么解决生产条件下多版本共存问题？如下`

### 组件版本语义化

> 例如：**版本 3.1.2 ， 一次对应（3为大版本号.1为次版本号.2为修订版本号）**
> 修订版本号: 紧急的bug修复，并且不调整API的情况下
> 次版本号: API增加的情况下
> 大版本号: API的更改、删除情况下 或 有重大技术革新情况（要有必要注明）

<br><br>

#### 【有了理论依据】
####    我们的文档则以大版本为分割，次版本和修正版本均在当前版本文档中描述；
####    如有大版本更新则需要新建路由并完善文档（重大技术革新是只需调整路由版本号，并备注说明即可）

`为此我们开发了vue插件用来引入版本组件，具体操作如下`

```js
export default {
    kscomponents:['KsPager_v0'],
    ...
}
```
**`有了细粒度的版本控制，我们可以同时保留多个版本，对于使用老版本的项目组，在时间充裕的时候更新组件`**（在设计上我们也尽力保持向下兼容，让小伙伴们在业务上尽量少的改动）
<br>

**`开发需要调整部分`**

<br><br>

> 组件调整，添加版本目录（可参考其它已调整组件结构）
> 文挡调整，添加版本目录（可参考其他修正文档）
> 路由部分调整，添加goName属性（解决点击左侧菜单跳转问题，可参考其他组件路由）


### 组件输出打包

```js
// 全量打包
npm run min 

// 指定组件打包
npm run min -a KsDatePicker

// 指定多个组件打包
npm run min -a KsDatePicker KsPage
```



> #### 在min目录下生成ks目录 ,此目录下会生成相应独立的组件、指令、过滤器
> 【以上单独导出组件要符合一定的目录结构，具体在 <a v-link="{name:'dir'}" title="">目录结构</a> 查看】

<br>

### 组件使用（全局注册）

```javascript
import { myModule } from './modulePath';

Vue.component('myModule', myModule);
```

### 组件使用（局部注册）
```javascript
import { myModule } from './modulePath';

export default {
  ...
  components:{
      myModule
  }    
  ...
}
```
